헤더
#pragma once
#include "gameNode.h"
#include "tile.h"
#include <vector>

//멀까 이건
#define ISO_UNMOVE UNMOVE

//########aStar관련 변수###########
struct tagAStarTile
{
	int tileNum;
	int parentNodeTileNum;
	int totalCost;
	int costFromStart;
	int costToGoal;
	bool isOpen;
};
//########aStar관련 변수###########

struct tagTilePoint
{
	float x;
	float y;
};

//내가 클릭한 현재 타일을 저장할 구조체
struct tagTempTile
{
	int fX;
	int fY;
};

struct tagSample
{
	RECT rc;
	int fX;
	int fY;
};

class Astar : public gameNode
{
private:
	isoTile		_isoTile[TILEX * TILEY];
	tagTilePoint	_tilePoint;
	tagSample		_sample[SAMPLEX * SAMPLEY];
	tagTempTile		_tempTile;

	//버튼 렉트들
	RECT			_saveBt;
	RECT			_saveBt2;
	RECT			_saveBt3;

	RECT			_loadBt;
	RECT			_loadBt2;
	RECT			_loadBt3;

	RECT			_move;
	RECT			_unMove;

	RECT			_undo;
	RECT			_fill;

	RECT			_open;
	RECT			_close;

	RECT			_small;
	RECT			_medium;
	RECT			_max;

	RECT			_leftBt;
	RECT			_rightBt;

	RECT			_goldBt;

	RECT			_menuRc;
	RECT			_objDel;

	RECT			_delAll;
	RECT			_homeBt;
	RECT			_dragBt;

	RECT			_tree1;
	RECT			_tree2;
	RECT			_tree3;
	RECT			_tree4;
	RECT			_tree5;
	RECT			_lava_obj1;
	RECT			_lava_obj2_l;
	RECT			_lava_obj2_r;
	RECT			_lava_obj3;


	RECT			_wall1;
	RECT			_wall2;
	RECT			_wall3;
	RECT			_wall4;

	RECT			_playerFlagRc;
	RECT			_enemyFlagRc;
	RECT			_dragRc;
	int _savePopUp; // 0이면 없는거고 1이면 저장잘됐다 2이면 오류메세지 팝업
	int _popUpCount;

	/////////////////////////////////////
	RECT			_icZergling;
	RECT			_icMarine;
	RECT			_icCivilian;
	RECT			_icTemplar;
	RECT			_icBishop;
	RECT			_icDiablo;
	RECT			_icSkeleton;
	RECT			_icGhost;
	RECT			_icDragon;
	RECT			_icTower1;
	/////////////////////////////////////
	POINT			_pickingPt;

	POINT			_cameraPtMouse; // 걍피티마우스말고 카메라위치 보정한 피티마우스

	bool			_moveUnMove;
	bool			_tempSaved;
	bool			_brushOn;
	bool			_objDelOn;
	bool			_menuInPt;
	bool			_dragMode;

	int _currentStage; // 몇 스테이지 작업중인지 (편의상 1,2,3)

	renderSize		_rs;
	menuNum			_menuNum;
	objName			_objName;

	//########aStar관련 변수###########
	vector<tagAStarTile*>			_vTotalList;
	vector<tagAStarTile*>::iterator _viTotalList;
	vector<tagAStarTile*>			_vOpenList;
	vector<tagAStarTile*>::iterator _viOpenList;
	vector<tagAStarTile*>			_vCloseList;
	vector<tagAStarTile*>::iterator _viCloseList;

	int _startTile;		//시작타일의 번호
	int _endTile;			//도착타일
	int _currentTile;		//현재타일

	bool _stop; // 못찾은거
	bool _seePath;

	int _playerTile; // 플레이어 깃발이 몇타일에 있는지 로드할때 불러온다.
	int _enemyTile; // 에너미 깃발이 몇타일에 있는지 로드할때 불러온다.

	int _modifyingNum; // 몇자리수째를 수정중인지 (0=수정중x, 1천자릿수 2백자릿수 3십자리수 4일의자리수)
	int _modifyingCount; // 5초카운트

	float _dragX; float _dragY;
	bool _push;
public:
	vector<int> aStarPath(int fromTileNum, int toTileNum);

	//갈수 있는 길을 찾아내서 담아줄 함수
	vector<tagAStarTile*> addOpenList(int currentTile);
	//빠른 경로 찾을 함수
	void pathFinder(int currentTile);
	//########aStar관련###########

public:
	Astar();
	~Astar();
	vector<int> _path;

	HRESULT init();
	void release();
	void update();
	void render();

	void createIsoMap(int tileX, int tileY);		//왼쪽에 베이스타일 깔아주는 함수
	void createSampleTiles();										//샘플타일 깔아주는 함수
	void ptInIso();												//샘플타일 안에 마우스가 들어갔을때
	void createTile();												//타일을 새롭게 업데이트 해주는 함수
	void imageInit();												//이미지 인잇
	void imageRender();												//이미지 렌더
	void moveUnMove();												//두개 버튼을 눌렀을때 일어나는 기능정의
	void openClose();												//브러쉬도구 접기 펼치기
	void renderSize();												//렌더 사이즈 조절
	void leftRightBt();												//브러쉬도구 메뉴 넘기기
	void ptInObj();													//오브젝트마다 고유이름을 주었기때문에 오브젝트 클릭시 효과를 다르게줄려고만듬
	void createObj();												//타일에 오브젝트 속성을 넣어주는 것
	void objDel();													//오브젝트 지우개
	void menuInPt();												//메뉴 안에 마우스가 들어갔을때 타일 안찍히게 막음
	void sampleInTemp();											//샘플 타일의 값을 템프에 담아주는 함수
	void homeBt();
	void tempDrag();												//누른 포인트 담기

	void save();
	void load();
	void tempSave();												//뒤로가기가 되어줄 상황(?)을 저장해서 담아주는 기능
	void tempLoad();												//뒤로가기의 상황(?)을 불러와줌

	void fill(int x, int y);										//전체 타일을 칠해주는 함수
	void objDelAll();												//오브젝트 전체를 지워주는 함수

	void cameraControl();
	void sampleTileMove();

	inline POINT picking(long x, long y); // 피킹하는 함수


	void numberInput();
};

//===========================================================================================================================================================
#include "stdafx.h"
#include "mapTool.h"

vector<int> Astar::aStarPath(int fromTileNum, int toTileNum)
{
	_path.clear();
	_vTotalList.clear();
	_vOpenList.clear();
	_vCloseList.clear();
	for (int i = 0; i < 900; ++i)
	{
		tagAStarTile* aStarTile = new tagAStarTile;
		aStarTile->tileNum = i;
		aStarTile->parentNodeTileNum = -1;
		aStarTile->totalCost = 0;
		aStarTile->costFromStart = 0;
		aStarTile->costToGoal = 0;
		aStarTile->isOpen = true;
		_vTotalList.push_back(aStarTile);
	}
	_stop = 0;
	_startTile = fromTileNum;
	_endTile = toTileNum;
	_currentTile = _startTile;
	pathFinder(_currentTile);

	return _path;
}

// #############################################################

vector<tagAStarTile*> Astar::addOpenList(int currentTile)
{
	int startX = currentTile % 30 - 1;
	int startY = currentTile / 30 - 1;

	for (int i = 0; i < 3; ++i)
	{
		//// ############ 벡터 안터지게 #####################
		if (startY + i < 0)			continue;
		if (startY + i >= 30)		continue;
		for (int j = 0; j < 3; ++j)
		{
			if (startX + j < 0)		continue;
			if (startX + j >= 30)	continue;

			int checkIndex = (startY + i) * 30 + (startX + j);
			tagAStarTile* aStarTile = _vTotalList[checkIndex];

			//예외처리!
			if (!aStarTile->isOpen) continue;
			if (_isoTile[checkIndex].MUM == UNMOVE) continue;
			if (checkIndex == _startTile) continue;

			// ##################월담 방지#############################
			int nodeTop;
			if (startY < 0)				nodeTop = 1;
			else nodeTop = _isoTile[(startY * 30) + startX + 1].MUM;
			// 위막혀있으면 왼쪽위와 오른쪽 위를 못가게함 i==0위 i==2아래 j==0왼 j==2오른
			if (i == 0 && nodeTop == 1)	continue;
			int nodeBottom;
			if (startY + 2 >= 30)	nodeBottom = 1;
			else nodeBottom = _isoTile[(startY * 30) + startX + 61].MUM;
			// 아래막혀있으면 왼쪽아래와 오른쪽 아래를 못가게함
			if (i == 2 && nodeBottom == 1)	continue;
			int nodeLeft;
			if (startX < 0)				nodeLeft = 1;
			else nodeLeft = _isoTile[(startY * 30) + startX + 30].MUM;
			// 왼쪽막혀있으면 왼쪽위와 왼쪽아래를 못가게함
			if (j == 0 && nodeLeft == 1)	continue;
			int nodeRight;
			if (startX + 2 >= 30)	nodeRight = 1;
			else nodeRight = _isoTile[(startY * 30) + startX + 32].MUM;
			// 오른쪽막혀있으면 오른쪽위와 오른쪽 아래로 못가게함
			if (j == 2 && nodeRight == 1)	continue;


			//현재 타일을 계속 갱신해준다
			aStarTile->parentNodeTileNum = _currentTile;

			bool addObj = true;
			for (_viOpenList = _vOpenList.begin(); _viOpenList != _vOpenList.end(); ++_viOpenList)
			{
				if (*_viOpenList == aStarTile)
				{ // 있는거면 추가안함
					addObj = false;
					break;
				}
			}
			if (!addObj) continue;

			_vOpenList.push_back(aStarTile);
		}
	}

	return _vOpenList;
}

void Astar::pathFinder(int currentTile)
{
	//경로비용을 매우 쉽게 하기 위해서 임의의 경로비용을 둠
	int tempTotalCost = 5000;
	tagAStarTile* tempTile = nullptr;

	bool changed = false;

	//갈수 있는 길을 담은 벡터 내부에서 가장 빠른 경로를 뽑아야한다
	for (int i = 0; i < addOpenList(currentTile).size(); ++i)
	{ // 여기서 주변방향 넣음과 동시에 리턴으로 총오픈리스트를 가져오는거
		_vOpenList[i]->costToGoal = (abs(_endTile % 30 - _vOpenList[i]->tileNum % 30) +
			abs(_endTile / 30 - _vOpenList[i]->tileNum / 30)) * 11;

		int cost;

		if (_vOpenList[i]->tileNum + 1 == _vOpenList[i]->parentNodeTileNum
			|| _vOpenList[i]->tileNum - 1 == _vOpenList[i]->parentNodeTileNum
			|| _vOpenList[i]->tileNum + 30 == _vOpenList[i]->parentNodeTileNum
			|| _vOpenList[i]->tileNum - 30 == _vOpenList[i]->parentNodeTileNum) cost = 9;
		else if (_vOpenList[i]->tileNum + 31 == _vOpenList[i]->parentNodeTileNum
			|| _vOpenList[i]->tileNum - 31 == _vOpenList[i]->parentNodeTileNum) cost = 8;
		else if (_vOpenList[i]->tileNum + 29 == _vOpenList[i]->parentNodeTileNum
			|| _vOpenList[i]->tileNum - 29 == _vOpenList[i]->parentNodeTileNum) cost = 16;

		_vOpenList[i]->costFromStart = cost;

		//F = G + H 니까~ 
		_vOpenList[i]->totalCost = _vOpenList[i]->costToGoal + _vOpenList[i]->costFromStart;

		//경로비용(F)이 가장 작은 애로 계속 갱신해준다
		if (tempTotalCost > _vOpenList[i]->totalCost)
		{
			tempTotalCost = _vOpenList[i]->totalCost;
			tempTile = _vOpenList[i];
		} // 열린리스트중 경로비용 가장작은애가 탐색되어 템프타일로 들어옴

		bool addObj = true;
		for (_viOpenList = _vOpenList.begin(); _viOpenList != _vOpenList.end(); ++_viOpenList)
		{
			if (*_viOpenList == tempTile)
			{ // 열린리스트에 템프타일이 있다면 -> 새로 열린놈들중에서도 비용값이 작은게 없다?
				addObj = false;
				changed = true;
				break;
			} // 불값만들고 포문에서 잡히면 false로 만드니 이중포문 안돌릴수있음
		}
		_vOpenList[i]->isOpen = false; // 닫음
		if (!addObj) continue;

		_vOpenList.push_back(tempTile); // 추가해야된다고 했으니 추가하는거
	}

	// ############## 경로 못찾으면 끝내는 함수 #####################
	if (!changed)
	{// 아무것도 변경안하고 포문이 무사히(?) 돌았다면 끝낸다
		_stop = true;
		return;
	}

	//도착했다면
	if (tempTile->tileNum == _endTile)
	{
		while (_currentTile != _startTile)
		{
			_path.push_back(_currentTile);
			_currentTile = _vTotalList[_currentTile]->parentNodeTileNum;
		}
		_stop = true;
		return;
	}

	_vCloseList.push_back(tempTile);
	// 템프타일을 닫힌리스트에 넣고 오픈리스트에선 빼줌. 그리고 현재타일로 해줌
	for (_viOpenList = _vOpenList.begin(); _viOpenList != _vOpenList.end(); ++_viOpenList)
	{
		if (*_viOpenList == tempTile)
		{
			_viOpenList = _vOpenList.erase(_viOpenList);
			break;
		}
	}

	_currentTile = tempTile->tileNum;

	if (!_stop) pathFinder(_currentTile);
}